# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Arma matrix to NumericMatrix
#'
#' @param x a Matrix
#'
#' @return same matrix but with NumericMatrix type.
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
mat_as_Numeric <- function(x) {
    .Call(`_SamplingC_mat_as_Numeric`, x)
}

#' @title NumericMatrix matrix to Arma
#'
#' @param x a Matrix 
#'
#' @return same matrix but with arma type.
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
mat_as_arma <- function(x) {
    .Call(`_SamplingC_mat_as_arma`, x)
}

#' @title svd in arma
#'
#' @param x Matrix X
#'
#' @return list of element of svd
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
svdArma <- function(x) {
    .Call(`_SamplingC_svdArma`, x)
}

#' @title Binomial coefficient
#'
#' @param n integer.
#' @param k integer.
#'
#'
#' @return binomial coefficient
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#'
#' @export
choose <- function(n, k) {
    .Call(`_SamplingC_choose`, n, k)
}

cube <- function(prob, Xbal) {
    .Call(`_SamplingC_cube`, prob, Xbal)
}

lcube <- function(prob, Xspread, Xbal) {
    .Call(`_SamplingC_lcube`, prob, Xspread, Xbal)
}

flightphase <- function(prob, Xbal) {
    .Call(`_SamplingC_flightphase`, prob, Xbal)
}

landingphase <- function(prob, probflight, Xbal) {
    .Call(`_SamplingC_landingphase`, prob, probflight, Xbal)
}

lcubeflightphase <- function(prob, Xspread, Xbal) {
    .Call(`_SamplingC_lcubeflightphase`, prob, Xspread, Xbal)
}

lcubelandingphase <- function(prob, probflight, Xspread, Xbal) {
    .Call(`_SamplingC_lcubelandingphase`, prob, probflight, Xspread, Xbal)
}

cubestratified <- function(prob, Xbal, integerStrata) {
    .Call(`_SamplingC_cubestratified`, prob, Xbal, integerStrata)
}

lcubestratified <- function(prob, Xspread, Xbal, integerStrata) {
    .Call(`_SamplingC_lcubestratified`, prob, Xspread, Xbal, integerStrata)
}

#' @title all test condition in Rcpp
#'
#' @param x vector of boolean
#'
#' @return true or false
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
all_sug <- function(x) {
    .Call(`_SamplingC_all_sug`, x)
}

#' @title colSums in Rcpp
#'
#' @param x Matrix X
#'
#' @return colSums
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
colSumsRcpp <- function(x) {
    .Call(`_SamplingC_colSumsRcpp`, x)
}

#' @title rowSums in Rcpp
#'
#' @param x Matrix X
#'
#' @return rowSums
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
rowSumsRcpp <- function(x) {
    .Call(`_SamplingC_rowSumsRcpp`, x)
}

#' @title Check equal
#'
#' @param x vector 
#' @param y vector
#'
#' @return return true if vector equal to each other
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
check_equal <- function(x, y) {
    .Call(`_SamplingC_check_equal`, x, y)
}

#' @title duplicated columns
#'
#' @param B Matrix B
#'
#' @return return vector of boolean
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
duplicatedCols <- function(B) {
    .Call(`_SamplingC_duplicatedCols`, B)
}

#' @title duplicated rows
#'
#' @param B Matrix B
#'
#' @return vector of boolean
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
duplicatedRows <- function(B) {
    .Call(`_SamplingC_duplicatedRows`, B)
}

#' @title is Identiy matrix
#'
#' @param M matrix 
#'
#' @return bool
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
isEye <- function(M) {
    .Call(`_SamplingC_isEye`, M)
}

#' @title reduced row echelon form arma implementation
#'
#'
#' @param M matrix 
#'
#' @return NULL (transform matrix)
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
rrefArma <- function(M) {
    invisible(.Call(`_SamplingC_rrefArma`, M))
}

#' @title title
#'
#' @description
#' description
#'
#'
#' @param prob inclusion probabilities
#' @param Bm matrix of auxiliary variables
#'
#' @details
#'
#' details
#'
#' @return a vector
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @seealso
#' func
#'
#' @examples
#'
#' @export
osffphase <- function(prob, Bm) {
    .Call(`_SamplingC_osffphase`, prob, Bm)
}

#' @title Fast Flight phase
#'
#'
#' @description
#' 
#' Modified version of \code{\link[BalancedSampling:flightphase]{flightphase}}
#'
#' @param prob vector of inclusion probabilities of size N.
#' @param Xbal Matrix of auxiliary variables of dimension N x p
#' @param order if reordering at first step, Default TRUE.
#' @param redux if the matrix should be reduced. Default FALSE.
#'
#' @details
#'
#' details
#'
#' @return a sample with at most p value not update to 0 or 1. 
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
ffphase <- function(prob, Xbal, order = TRUE, redux = FALSE) {
    .Call(`_SamplingC_ffphase`, prob, Xbal, order, redux)
}

#' @title title
#'
#' @description
#' description
#'
#'
#' @param B matrix of auxiliary variables.
#' @param pik vector of inclusion probabilities
#' @param EPS tolerance
#'
#' @return updated pik
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
onestep <- function(B, pik, EPS = 0.0000001) {
    .Call(`_SamplingC_onestep`, B, pik, EPS)
}

#' @title title
#'
#'
#'
#' @param X matrix of auxiliary variables.
#' @param pik vector of inclusion probabilities
#' @param EPS tolerance
#'
#' @return a sample
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
flightphase_arma2 <- function(X, pik, EPS = 0.0000001) {
    .Call(`_SamplingC_flightphase_arma2`, X, pik, EPS)
}

#' @title title
#'
#'
#'
#' @param X matrix of auxiliary variables.
#' @param pik vector of inclusion probabilities
#' @param EPS tolerance
#'
#' @return a sample
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
flightphase_arma <- function(X, pik, EPS = 0.0000001) {
    .Call(`_SamplingC_flightphase_arma`, X, pik, EPS)
}

#' @title Reduction of the matrix
#'
#' @description 
#' 
#' This function reduces the size of the matrix by removing alternatively columns and rows that have sum equal to 0.
#' 
#' In case where the number of auxiliary varibale is great (p very large), even if we use the fast implementation proposed by
#' (Chauvet and Tillé 2005) the problem is time consuming. If we have the chance that the matrix is strongly sparse,
#' we can then use the function to reduce the size of the matrix B by using this method. 
#' 
#' If the matrix is dense or every column have sum greater than 0, then nothing is changed.
#'
#' @param B a matrix of size (p+1 x p) sub-matrix of auxiliary matrix.
#'
#' @return a list
#' 
#' @references 
#' Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. Computational Statistics, 21/1:53–62. 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' 
#' @export
reduxArma <- function(B) {
    .Call(`_SamplingC_reduxArma`, B)
}

#' @title Column sums for sparseMatrix
#'
#' @description
#' Form column sums for sparseMatrix.
#'
#' @param x A sparse matrix, i.e., inheriting from \code{\link[Matrix]{sparseMatrix}}.
#'
#' @details
#' This function is designed to be used for internal \code{RcppArmadillo} functions. Nevertheless it could be applied in R.
#' It loops on the non-zero entries of the \code{\link[Matrix]{sparseMatrix}}. For general uses, the function
#' \code{\link[Matrix]{colSums}} should be prefered.
#'
#' @return column sums of x.
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @seealso
#' \code{\link[Matrix]{colSums}}, \code{\link[Matrix]{rowSums}}.
#'
#' @export
colSumsiter <- function(x) {
    .Call(`_SamplingC_colSumsiter`, x)
}

#' @title Row sums on sparse matrix.
#'
#' @description
#' Form row sums for sparseMatrix.
#'
#' @param x A sparse matrix, i.e., inheriting from \code{\link[Matrix]{sparseMatrix}}.
#'
#' @details
#' This function is designed to be used for internal \code{RcppArmadillo} functions. Nevertheless it could be applied in R.
#' It loops on the non-zero entries of the \code{\link[Matrix]{sparseMatrix}}. For general uses, the function \code{\link[Matrix]{rowSums}} should
#' be prefered.
#'
#' @return row sums of x. 
#' 
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @seealso
#' \code{\link[Matrix]{colSums}}, \code{\link[Matrix]{rowSums}}.
#' 
#' @export
rowSumsiter <- function(x) {
    .Call(`_SamplingC_rowSumsiter`, x)
}

#' @title reduced row echelon form arma implementation
#'
#'
#' @param M matrix 
#'
#' @return NULL (transform matrix)
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
rrefArmaExport <- function(M) {
    invisible(.Call(`_SamplingC_rrefArmaExport`, M))
}

#' @title reduced row echelon fom
#'
#'
#' @param M matrix 
#'
#' @return NULL (transform matrix)
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
rrefBal <- function(M) {
    invisible(.Call(`_SamplingC_rrefBal`, M))
}

#' @title All samples of fixed size
#'
#' @description
#' description Rosetta code combn
#'
#'
#' @param N population size
#' @param n sample size
#'
#'
#' @return a matrix of all samples of fixed size.
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @export
samplen <- function(N, n) {
    .Call(`_SamplingC_samplen`, N, n)
}

#' @encoding UTF-8
#' @title systematic desgin
#'
#' @description
#'
#' Find all possible systematic sample from a vector of inclusion probabilities \code{pik}.
#'
#' @param pik vector of inclusion probabilities..
#'
#' @return A matrix of size at most N x N with elements equal to 0 or 1. The value 1 indicates that the uni is selected while the value 0 is for non-chosen unit.
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#'
#' @export
systematicDesign <- function(pik) {
    .Call(`_SamplingC_systematicDesign`, pik)
}

#' @title kernel vector
#' @param Bm matrix
#' @return a null vector
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @export
ukern <- function(Bm) {
    .Call(`_SamplingC_ukern`, Bm)
}

#' @title kernel vector arma
#' @param Bm matrix
#' @return a null vector
#'
#'
#' @author Raphaël Jauslin \email{raphael.jauslin@@unine.ch}
#' 
#' @export
ukernArma <- function(Bm) {
    .Call(`_SamplingC_ukernArma`, Bm)
}

